# Linear sort
线性的时间复杂度排序算法称为线性排序，是由于非基于比较的排序算法，不涉及元素之间的比较算法

## Bucket sort
将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序，桶内排序完后，再把桶里的数据按照次序依次去除，组成的序列就是有序的
```
// 需要排序的数据: n
// 桶: m
// 每个桶内部使用快速排序，时间复杂度: o(n/m * log(n/m))
// m 个桶，时间复杂度: o(n * log(n/m))
// 当 m 无限接近于 n: o(n) 
``` 
 桶排序的使用场景: 数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中

## Counting sort
当要排序的 n 个数据，所处的范围并不大，最大值为 k, 把数据划分为 k 个桶，每个桶内的数据都是相同的
```
// 8 名学生，分数覆盖范围 0 ～ 5
// 成绩 A[8] = [2, 5, 3, 0, 2, 3, 0, 3]
// 数据划分 C[6] = [2, 0, 2, 3, 0, 1]
// 将 C[6] 进行加和 B[6] =  [2, 2, 4, 7, 7, 8]
// 有序数组 R[8] = [null, null, null, null, null(3), null(3), null(3), null]
```
1. 计数排序只适用于数据范围不大的场景中
2. 计数排序只能给非负整数排序

## Radix sort
- 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
- 每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 o(n) 了。

## Example
👉  如何根据年龄给 100 万用户排序?
```
// 年龄范围: 0 ~ 100
// 我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。
```
